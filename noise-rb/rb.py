# Import general libraries (needed for functions)
import numpy as np
import matplotlib.pyplot as plt
from IPython import display

# Import the RB Functions
import qiskit.ignis.verification.randomized_benchmarking as rb

# Import Qiskit classes
import qiskit
from qiskit import assemble, transpile
from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute

# Import Backends
from quantuminspire.qiskit import QI

# Import utils
import sys
sys.path.append('..')
import utils as u
import time

# Login
u.set_auth('../credentials/auth.json')
# Get available backends
QI.backends()


def single_qubit_rb(shots, nseeds):
    """
    Generate single qubit RB circuits (5Q RB), assumes native gates [Rx, Ry].
    All five qubits are benchmarked together to take crosstalks into account.

    parameters:
    shots [int]: number of shots per circuit
    nseeds [int]: number of different circuits per RB configuration

    return:
    job_list [list]: list of QIJob for RB simulations
    transpile_list [list]: list of QuantumCircuit generated by RB experiments
    """

    # Setup RB circuit parameters
    nQ = 5 # Can benchmark 5 qubits for once
    nCliffs = np.arange(1,200,20)
    rb_pattern = [[0], [1], [2], [3], [4]]
    length_multiplier = [3, 3, 3, 3, 3]

    # Construct RB circuits according to the parameters
    rb_opts = {}
    rb_opts['length_vector'] = nCliffs
    rb_opts['nseeds'] = nseeds
    rb_opts['rb_pattern'] = rb_pattern
    rb_opts['length_multiplier'] = length_multiplier
    rb_circs, xdata = rb.randomized_benchmarking_seq(**rb_opts)

    # Get backend and define native gates
    backend = QI.get_backend('Starmon-5')
    basis_gates = ['rx', 'ry']

    # Record job and circuit information for error rate calculation
    job_list = []
    transpile_list = []
    for rb_seed,rb_circ_seed in enumerate(rb_circs):
        print('Compiling seed %d'%rb_seed)
        rb_circ_transpile = qiskit.transpile(rb_circ_seed, basis_gates=basis_gates)
        transpile_list.append(rb_circ_transpile)
        print('Submitting seed %d'%rb_seed)
        job = qiskit.execute(rb_circ_transpile, shots=shots, backend=backend, backend_options={'max_parallel_experiments': 0})
        job_list.append(job)
    print("Finished Submission")

    return job_list, transpile_list



def double_qubit_rb(qbt_pair, shots, nseeds):
    """
    Generate two qubit RB circuits (2Q RB), assumes native gates [Rx, Ry, CZ].
    Useful for one who intends to encode states in more than one qubit, e.g. 3-qubit repetition code

    parameters:
    qbt_pair [list]: list of two numbers specifying the qubits to undergo RB
    shots [int]: number of shots per circuit
    nseeds [int]: number of different circuits per RB configuration

    return:
    job_list [list]: list of QIJob for RB simulations
    transpile_list [list]: list of QuantumCircuit of the RB generated
    """

    # Setup RB circuit parameters
    nQ = 2 # Can benchmark 2 qubit once at most due to tomography
    nCliffs = np.arange(1,200,20)
    rb_pattern = [[qb_pair]]
    length_multiplier = [1]

    # Construct RB circuits according to the parameters
    rb_opts = {}
    rb_opts['length_vector'] = nCliffs
    rb_opts['nseeds'] = nseeds
    rb_opts['rb_pattern'] = rb_pattern
    rb_opts['length_multiplier'] = length_multiplier
    rb_circs, xdata = rb.randomized_benchmarking_seq(**rb_opts)

    # Get backend and define native gates
    backend = QI.get_backend('Starmon-5')
    basis_gates = ['rx', 'ry', 'cz']

    # Record job and circuit information for error rate calculation
    job_list = []
    transpile_list = []
    print("Qubit pair (%d, %d)" % (qb_pair[0], qb_pair[1]))
    for rb_seed,rb_circ_seed in enumerate(rb_circs):
        print('Compiling seed %d'%rb_seed)
        rb_circ_transpile = qiskit.transpile(rb_circ_seed, basis_gates=basis_gates)
        transpile_list.append(rb_circ_transpile)
        print('Submitting seed %d'%rb_seed)
        job = qiskit.execute(rb_circ_transpile, shots=shots, backend=backend, backend_options={'max_parallel_experiments': 0})
        job_list.append(job)
    print("Finished Submission")

    return job_list, transpile_list



def plot_1qbt_rb(result_list, xdata, savefig=False):
    """
    Plot RB results on sinlge qubits.
    Clifford length: number of clifford elements in the RB circuit
    Ground state population: state fidelity after action by a number of cliffords in the circuit
    EPC: error per clifford
    alpha: fitting parameter

    parameters:
    result_list [list]: list of QIResult that contains RB results
    xdata [list]: list of list(s) of Clifford lengths tested on each qubit in RB
    savefig [Bool]: Boolean value for deciding whether to save the final round of plotted result
    """
    # Construct the fitting function for the first set of RB result
    rbfit = rb.fitters.RBFitter(result_list[0], xdata, rb_opts['rb_pattern'])

    # Iterate through all RB experiments
    for seed_num, data in enumerate(result_list):
        # Construct plots
        plt.figure(figsize=(22, 14))
        axis = [plt.subplot(231), plt.subplot(232), plt.subplot(233), plt.subplot(234), plt.subplot(236)]

        # Add another seed to the data
        rbfit.add_data([data])
        # Iterate through all qubits
        for i in range(5):
            pattern_ind = i
            # Plot by plot_rb_data
            rbfit.plot_rb_data(pattern_ind, ax=axis[i], add_label=True, show_plt=False)
            # Add title and label
            axis[i].set_title('Qubit %d RB - after seed %d'%(rb_opts['rb_pattern'][i][0], seed_num), fontsize=18)
        # Display
        display.display(plt.gcf())
        # Save final results optionally
        if (seed_num == len(result_list)-1) and (savefig == True):
            plt.savefig("single-rb-results.pdf")
        # Clear display after each seed and close
        display.clear_output(wait=True)
        time.sleep(1.0)
        plt.close()


def get_gate_num(circuit_list, xdata, rb_pattern):
    """
    Count the number of single gates in the RB Cliffords for qubit 0 to 5 respectively

    parameters:
    circuit_list [list]: list of QuantumCircuit generated by RB experiments
    xdata [list]: list of list(s) of Clifford lengths tested on each qubit in RB
    rb_pattern [list]: list of the form [[i,j], [k], ...], where i, j, k are qubit numbers in simultaneous
                       RB experiments

    return:
    avg_gate_list [list]: list of gate numbers in basis gates for qubit 0 to 5 respectively
    """

    avg_gate_list = []
    # Iterate through all qubits in the machine
    for i in range(5):
        qubits = rb_pattern[i]
        # Define native gate sets
        basis_gates = ['rx', 'ry']
        # Calculate average gate number per clifford
        gate_per_cliff = rb.rb_utils.gates_per_clifford(
            transpiled_circuits_list=circuit_list,
            clifford_lengths=xdata[i],
            basis=basis_gates,
            qubits=qubits)

        # Print results
        print("Qubit %d:" % i)
        for basis_gate in basis_gates:
            avg_gates = np.mean([gate_per_cliff[qubit][basis_gate] for qubit in qubits])
            avg_gate_list.append(avg_gates)
            print("Number of %s gates per Clifford: %f"%(
                basis_gate,
                avg_gates))

    return avg_gate_list
