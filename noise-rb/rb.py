# Import general libraries
import time
import math
import numpy as np
import matplotlib.pyplot as plt
from IPython import display

# Import Qiskit classes
import qiskit
from qiskit import QuantumCircuit, assemble, transpile, execute

# Import the RB Functions
import qiskit.ignis.verification.randomized_benchmarking as rb


def run_rb(nQ, nCliffs, pattern, len_multiplier, shots, nSeeds, backend, basis_gates):
    """
    Generate single qubit RB circuits with input as specs.
    Note: if all qubits are benchmarked together, one can take into account possible crosstalks in the hardware.

    Parameters:
    nQ [int]: number of qubits intended for RB experiments
    nCliffs [array]: array of clifford lengths (i.e. number of clifford elements) to test in RB experiments respectively
    pattern [list]: list of the form [[i,j], [k], ...], where i, j, k are qubit indices in simultaneous RB experiments
    len_multiplier [array/list]: array or list of integers >=1 for scaling nCliffs
    shots [int]: number of shots per RB circuit
    nseeds [int]: number of different circuits per RB configuration
    backend: simulator/hardware to run RB experiment on
    basis_gates [list]: list of gates in string form (i.e. "cz", "rx" etc.) to decompose RB circuits in

    Returns:
    job_list [list]: list of Job Objects for RB simulations
    transpile_list [list]: list of QuantumCircuit generated by RB experiments
    xdata [list]: list of the form [[m, ...], [n, ...], ...], where each list in xdata specify a set of Clifford lengths
                  tested on the corresponding qubit(s) in RB
    """
    # Check if RB qubit pattern matches with intended qubit number
    nQpattern = 0
    for qubits in pattern:
        nQpattern += len(qubits)
    if nQpattern != nQ:
        raise ValueError("Qubit number does not match input qubit pattern.")

    # Construct RB operations according to the input parameters
    rb_opts = {}
    rb_opts['length_vector'] = nCliffs
    rb_opts['nseeds'] = nSeeds
    rb_opts['rb_pattern'] = pattern
    rb_opts['length_multiplier'] = len_multiplier
    rb_circs, xdata = rb.randomized_benchmarking_seq(**rb_opts)

    # Record job and circuit information for error rate calculation
    job_list = []
    transpile_list = []
    for rb_seed, rb_circ_seed in enumerate(rb_circs):
        print('Compiling seed %d'%rb_seed)
        rb_circ_transpile = qiskit.transpile(rb_circ_seed, basis_gates=basis_gates)
        transpile_list.append(rb_circ_transpile)
        print('Submitting seed %d'%rb_seed)
        job = qiskit.execute(rb_circ_transpile, shots=shots, backend=backend, backend_options={'max_parallel_experiments': 0})
        job_list.append(job)
    print("Finished Submission")

    return job_list, transpile_list, xdata


def plot_rb(result_list, pattern, xdata, savedata=False, savefig=False):
    """
    Plot/record RB results from experiments. Currently supports 1QB and 2QB RB plotting.
    Clifford length: number of clifford elements tested in RB experiments
    Ground state population: state fidelity after action by a number of cliffords in the circuit
    EPC: error per clifford
    alpha: fitting parameter

    parameters:
    result_list [list]: list of QIResult that contains RB results
    pattern [list]: list of the form [[i,j], [k], ...], where i, j, k are qubit indices in simultaneous RB experiments
    xdata [list]: list of the form [[m, ...], [n, ...], ...], where each list in xdata specify a set of Clifford lengths
                  tested on the corresponding qubit(s) in RB
    savedata [Bool]: Boolean value for deciding whether to save the final round of RB fitting result
    savefig [Bool]: Boolean value for deciding whether to save the final round of plotted result
    """
    # Construct the fitting function for the first set of RB result
    rbfit = rb.fitters.RBFitter(result_list[0], xdata, pattern)
    max_seed = len(result_list)-1

    # Iterate through all RB experiments
    for seed_num, data in enumerate(result_list):
        # Construct plots
        plt.figure(figsize=(22, 14))
        axis = [plt.subplot(231), plt.subplot(232), plt.subplot(233), plt.subplot(234), plt.subplot(236)]

        # Add another seed to the data
        rbfit.add_data([data])
        # Iterate through all qubit patterns ran in the experiment
        for i in range(len(pattern)):
            pattern_ind = i
            # Plot by plot_rb_data
            rbfit.plot_rb_data(pattern_ind, ax=axis[i], add_label=True, show_plt=False)
            # Add title and label
            if len(pattern[i]) == 1:
                axis[i].set_title('Qubit %d RB - after seed %d' % (pattern[i][0], seed_num), fontsize=18)
            elif len(pattern[i]) == 2:
                axis[i].set_title('Qubit (%d, %d) RB - after seed %d' % (pattern[i][0], pattern[i][1], seed_num), fontsize=18)

        # Display
        display.display(plt.gcf())
        # Save plot optionally
        if (seed_num == max_seed) and (savefig == True):
            plt.savefig("rb-results.pdf")
            # print("Saved RB plot.")
        # Clear display after each seed and close
        display.clear_output(wait=True)
        time.sleep(1.0)
        plt.close()

    # Save RB fit optionally
    if (savedata == True):
        # print("Saved RB data.")
        return rbfit.fit



def get_gate_num(circuit_list, xdata, pattern, basis_gates):
    """
    Count the number of single or two-qubit gates in the RB Clifford circuits for a given qubit pattern

    parameters:
    circuit_list [list]: list of QuantumCircuit generated by RB experiments
    xdata [list]: list of the form [[m, ...], [n, ...], ...], where each list in xdata specify a set of Clifford lengths
                  tested on the corresponding qubit(s) in RB
    pattern [list]: list of the form [[i,j], [k], ...], where i, j, k are qubit numbers in simultaneous RB experiments
    basis_gates [list]: list of gates in string form (i.e. "cz", "rx" etc.) to decompose RB circuits in

    return:
    avg_gate_list [list]: list of gate numbers in basis gates for the given qubit pattern
    """
    avg_gate_list = []
    # Iterate through all qubits in the machine
    for i in range(len(pattern)):
        # Calculate average gate number per clifford
        qubits = pattern[i]
        gate_per_cliff = rb.rb_utils.gates_per_clifford(
            transpiled_circuits_list=circuit_list,
            clifford_lengths=xdata[i],
            basis=basis_gates,
            qubits=qubits)
        avg_gate_list.append(gate_per_cliff)

        # Print results
        print("Qubit(s):", qubits)
        for basis_gate in basis_gates:
            avg_gates = np.mean([gate_per_cliff[qubit][basis_gate] for qubit in qubits])
            print("Number of %s gates per Clifford: %f"%(basis_gate, avg_gates))

    return avg_gate_list
